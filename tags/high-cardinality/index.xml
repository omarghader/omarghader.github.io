<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>high-cardinality on</title><link>https://omarghader.github.io/tags/high-cardinality/</link><description>Recent content in high-cardinality on</description><generator>Hugo -- gohugo.io</generator><language>en-US</language><lastBuildDate>Sat, 12 Apr 2025 21:48:36 +0000</lastBuildDate><atom:link href="https://omarghader.github.io/tags/high-cardinality/index.xml" rel="self" type="application/rss+xml"/><item><title>High-Cardinality Metrics: Detection and Optimization in Prometheus and VictoriaMetrics</title><link>https://omarghader.github.io/high-cardinality-optimization-victoriametrics-prometheus/</link><pubDate>Sat, 12 Apr 2025 21:48:36 +0000</pubDate><guid>https://omarghader.github.io/high-cardinality-optimization-victoriametrics-prometheus/</guid><description>High-Cardinality Metrics: Detection and Optimization in Prometheus and VM I remember the first time my Prometheus instance crashed spectacularly after I added a new exporter. The logs screamed about &amp;ldquo;out of memory&amp;rdquo; errors, and my Grafana dashboards turned into ghost towns. After some frantic debugging, I discovered the culprit: high-cardinality metrics.
In this guide, I&amp;rsquo;ll share practical techniques I&amp;rsquo;ve learned for identifying and optimizing these metric monsters in both Prometheus and VictoriaMetrics.</description></item></channel></rss>